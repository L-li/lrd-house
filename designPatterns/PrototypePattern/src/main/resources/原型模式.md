# *原型模式*
### 一：*介绍*

---
>#### 原型模式（Prototype Pattern）使用原型实例指定创建对象的种类，并且通过克隆这些原型创建新的对象。

---

###  二：*应用场景*

>#### 需要创建一个复杂的、构造耗时很多的对象，且已有一个同类对象的时候。

>####  消费者不关心对象构造过程的时候。

>####  复杂数据实体的复制。

---


###  三：*具体实现方式*



####浅克隆
#####定义实体类

```
package com.Prototype;

import java.util.Date;

public class Person implements Cloneable {

    private String name;

    private Date birthday;


    @Override
    protected Person clone() throws CloneNotSupportedException {
        Person person = (Person) super.clone();
        return person;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

}


```

#####客户端调用

```
package com.Prototype;

import java.util.Date;

public class Client {
    public static void main(String[] args) throws Exception {
        Date date = new Date(1234455667);
        Person person1 = new Person();
        person1.setName("李四");
        person1.setBirthday(date);
        Person person2 = person1.clone();
        person1.setBirthday(date);
        System.out.println(person1);
        System.out.println(person2);
        // person2.setName("张三");   改变person2的属性

        System.out.println(person2.getName());
//        System.out.println(person2.getBirthday());

    }
}

//控制台输出
李四
com.Prototype.Person@22a71081
com.Prototype.Person@3930015a
```

####深克隆
#####定义实体类
```

package com.Prototype;

import java.util.Date;

public class DeepPerson implements Cloneable {

    private String name;

    private Date birthday;


    @Override
    protected DeepPerson clone() throws CloneNotSupportedException {
        DeepPerson person = (DeepPerson) super.clone();
        person.birthday = (Date) this.birthday.clone();
        return person;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

}


```
#####客户端调用

```
package com.Prototype;

import java.util.Date;

public class Client {
    public static void main(String[] args) throws Exception {

        /**
         * 深克隆
         */
        DeepPerson deepPerson = new DeepPerson();
        deepPerson.setBirthday(date);
        DeepPerson deepPerson1 = deepPerson.clone();
        date.setTime(1233422342);
        deepPerson.setBirthday(date);
        System.out.println(deepPerson.getBirthday());
        System.out.println(deepPerson1.getBirthday());

    }
}

```

### 四：*原型模式的注意事项*

 - 使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。
   不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。单例模式中，只要将构造方法的访问权限设置为private型，就可以实现单例。
   但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的，在使用时要特别注意。

- 深拷贝与浅拷贝。Object类的clone方法只会拷贝对象中的基本的数据类型（8种基本数据类型byte,char,short,int,long,float,double，boolean）。
  对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。
  至于String这个类型需要注意，它是引用数据类型，所以是浅拷贝